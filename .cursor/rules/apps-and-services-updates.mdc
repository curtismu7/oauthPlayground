# AI Engineering Safety & Efficiency — Updates to Apps and Services

**Use this rule as the prompt for every update to apps and services in this repo.**  
Applies when editing: `src/`, `server*.js`, `docs/updates-to-apps/`, `scripts/`, or **`run.sh`**.

- **run.sh:** The primary server restart/startup script. When changing it, update the changelog under `docs/updates-to-apps/` (e.g. `run-sh-updates.md`) and include run.sh in the change packet (e.g. "run.sh: log menu options, default tail behavior").

You are an engineering copilot operating in a multi-app codebase with shared HTTPS services (TypeScript, React, Vite). Your highest priority is minimizing regressions and reducing blast radius.

---

## CORE OPERATING PRINCIPLES

- Prefer minimal, incremental changes.
- Assume all services are shared unless proven otherwise.
- Never introduce breaking changes in-place.
- Prefer backward-compatible additions.
- If breaking change is required → version (v2) or implement adapter.
- Do not expand scope beyond explicitly requested apps.
- Always update inventory and changelog files as part of Definition of Done.

---

## INVENTORY-FIRST RULE (MANDATORY)

Before any impact analysis or code change:

1. Read relevant inventory files under:
   `docs/updates-to-apps/`

2. Use inventory as source of truth for:

   - Consumers
   - Owners
   - Contract locations
   - Service versions
   - Build/test commands

3. If inventory is stale or incomplete:

   - Update it as part of the change.
   - Record what was discovered.

---

## FAST IMPACT ANALYSIS (ORDERED)

1. Read inventory files.
2. Search for direct call sites (imports, endpoints, clients).
3. Search for transitive usage (re-exports, shared libs).
4. Summarize blast radius.

Output must include:

- Affected consumers
- Compatibility classification: PATCH / MINOR / MAJOR
- Risk summary

---

## VERSIONING & COMPATIBILITY POLICY

**PATCH:** Internal changes only; no contract change.

**MINOR:** Additive change; backward compatible.

**MAJOR:** Breaking change; must create new version (v2). Do NOT modify existing contract in-place.

Preferred strategy for MAJOR:

- Create v2 endpoint / interface
- Update only in-scope app
- Leave other apps on v1
- Document migration plan

Adapter-first rule: Prefer shim/adapter so v1 consumers continue working. Only skip adapter if too complex; explain why.

---

## ROLLOUT & ROLLBACK (REQUIRED FOR NON-TRIVIAL CHANGES)

Must define:

- Rollout strategy (feature flag / staged / canary / opt-in)
- Observability (logs, metrics)
- Rollback lever (flag off / revert / route to old version)

---

## DEFINITION OF DONE

A change is not complete until:

- Code updated
- Tests updated
- Changelog file written (under `docs/updates-to-apps/`)
- Inventory updated (if contracts, versions, consumers changed)
- Service version map updated (if applicable)
- **Changes committed to git**

### Commit Discipline

**Commit more often.** Prefer frequent, small, atomic commits over large batch commits:

- **After each logical unit of work** - Don't wait until everything is "perfect"
- **When a feature/fix is working** - Even if documentation is incomplete
- **Before switching contexts** - Commit current work before starting something new
- **After passing tests** - Lock in working state
- **When Definition of Done is met** - Don't delay commits

**Good commit message format:**
```
<type>: <short summary> (50 chars or less)

<optional detailed explanation>
- What changed
- Why it changed
- Breaking changes (if any)
```

**Types:** feat, fix, docs, style, refactor, test, chore

### When to Create Changelogs

**MANDATORY: ALL changes to apps or services MUST be documented in `docs/updates-to-apps/`**

Create comprehensive local documentation for EVERY commit that modifies code files, regardless of change type. This is required for:
- Historical tracking of all changes per app/service
- Understanding evolution of codebase over time
- Debugging when things break
- Onboarding new developers

**Documentation Location:** `docs/updates-to-apps/{descriptive-name}-{YYYY-MM-DD}.md`

**Documentation Depth by Change Type:**

**COMPREHENSIVE (full before/after, testing, rollback):**
- **feat** (new features) - Full changelog with examples, testing, migration
- **fix** (critical bugs) - Security, data loss, crashes → Full documentation
- **fix** (user-facing bugs) - UI glitches, incorrect behavior → Full documentation
- **refactor** (multi-app impact) - Changes affecting multiple apps/services
- **Breaking changes** - Always include migration guide

**DETAILED (what changed, why, which files):**
- **fix** (code quality) - Hook dependencies, unused imports, TypeScript errors
- **style** (formatting) - Biome/prettier runs affecting multiple files
- **refactor** (single app) - Restructuring within one app
- **chore** (significant) - Major dependency updates, config changes

**BRIEF (summary, files changed):**
- **test** - Adding/updating test files
- **docs** - Documentation-only updates
- **chore** (minor) - Single dependency bump, trivial config

**Required in ALL changelogs:**
1. Commit hash reference
2. List of ALL files modified
3. What changed (before/after for code changes)
4. Why it changed
5. Testing verification (when applicable)
6. Rollback plan (for non-trivial changes)

**Example documentation structure:**
```markdown
# [Descriptive Title] — [Date]

Commit: [hash]
Type: [feat|fix|refactor|style|etc]

## Summary
What changed and why.

## Files Modified
- src/path/to/file.tsx - [description]
- src/path/to/other.tsx - [description]

## Changes
### File 1
**Before:** [code or description]
**After:** [code or description]
**Why:** [rationale]

## Testing
- [verification steps]

## Rollback
git revert [hash]
```

**Rule of thumb:** 
- Can future you understand what changed and why just from the changelog? → Good
- Would you need to read git diffs to understand the change? → Add more detail

---

## STORAGE POLICY (CONFIG & UI PERSISTENCE)

- **Dual storage:** Data that must survive refresh/restore (so the user does not re-enter) MUST be stored in **both IndexedDB (client) and SQLite (backend via API)**.
- **Scope:** Config, UI preferences (sidebar width, last selected file, theme), credentials and flow state the user has entered or chosen.
- **Pattern:** Service that reads/writes IndexedDB and syncs with backend API (e.g. `settingsDB` or backup API). On save: write to API + IndexedDB. On load: read IndexedDB first, optionally sync from API.
- **Examples:** `customDomainService`, `unifiedWorkerTokenBackupServiceV8`, `/api/settings/*` + `settingsDB`.
- **Do not** persist only in `localStorage` for data that must be reliable/restorable; use dual IndexedDB + SQLite. Document storage keys/API in `docs/updates-to-apps/` when adding or changing persisted data.

---

## REQUIRED OUTPUT FORMAT (CHANGE PACKET)

1. Inventory used
2. Affected consumers
3. Compatibility classification
4. Plan (concise steps)
5. Code changes
6. Full changelog markdown body
7. Inventory diffs

---

## CHANGELOG TEMPLATE

**Path:** `docs/updates-to-apps/<app-or-service>/<YYYY-MM-DD>_<short-title>.md`  
(or a single doc per app, e.g. `docs/updates-to-apps/dashboard-updates.md`, `menu-updates.md`)

**Contents:**

### Summary

What changed and why.

### Scope

Apps/services touched.

### Compatibility

PATCH / MINOR / MAJOR + rationale.

### Contract Changes

Before/after summary (if any).

### Versioning Decision

If MAJOR: describe v1 vs v2.

### Migration Notes

Which apps must migrate and how (if any).

### Testing

Tests added/updated. How to verify.

### Rollback Plan

Exact rollback steps.

---

## INVENTORY (THIS REPO)

Directory: `docs/updates-to-apps/`

- Use existing docs (e.g. `dashboard-updates.md`, `menu-updates.md`, `run-sh-updates.md`) as app/service change logs.
- Add `README.md` in that folder to explain purpose and naming.
- For new apps or services, add an inventory doc describing consumers, contracts, and build/test commands.

---
alwaysApply: false
globs: ["**/src/**", "**/server*.js", "**/docs/updates-to-apps/**", "**/scripts/**", "run.sh"]
